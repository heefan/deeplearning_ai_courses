"""
Safe Python code executor for generated chart code.

This module provides secure execution of Python code generated by the agents,
with proper sandboxing, timeout protection, and error handling.
"""

import re
import asyncio
import subprocess
import tempfile
import os
from pathlib import Path
from typing import Optional, Dict, Any, List
from dataclasses import dataclass
import json


@dataclass
class ExecutionResult:
    """Result of code execution."""
    success: bool
    output: str
    error: Optional[str]
    execution_time: float
    generated_files: List[str]
    return_code: int


class CodeExecutor:
    """
    Safe executor for Python code generated by the agents.
    
    This class provides secure execution of Python code with:
    - Code extraction from <execute_python> tags
    - Restricted execution environment
    - Timeout protection
    - Output capture and validation
    """
    
    def __init__(
        self,
        timeout: int = 30,
        output_dir: str = "./outputs",
        allowed_imports: Optional[List[str]] = None
    ):
        """
        Initialize the code executor.
        
        Args:
            timeout: Maximum execution time in seconds
            output_dir: Directory for generated files
            allowed_imports: List of allowed import modules (None for all)
        """
        self.timeout = timeout
        self.output_dir = Path(output_dir)
        self.allowed_imports = allowed_imports or [
            "matplotlib", "pandas", "numpy", "datetime", "json"
        ]
        
        # Create output directory if it doesn't exist
        self.output_dir.mkdir(parents=True, exist_ok=True)
    
    def extract_code(self, code_with_tags: str) -> str:
        """
        Extract Python code from <execute_python> tags.
        
        Args:
            code_with_tags: Code wrapped in <execute_python> tags
            
        Returns:
            Extracted Python code
            
        Raises:
            ValueError: If code tags are malformed
        """
        # Pattern to match <execute_python>...</execute_python>
        pattern = r'<execute_python>(.*?)</execute_python>'
        matches = re.findall(pattern, code_with_tags, re.DOTALL)
        
        if not matches:
            raise ValueError("No <execute_python> tags found in code")
        
        if len(matches) > 1:
            raise ValueError("Multiple <execute_python> tags found")
        
        return matches[0].strip()
    
    async def execute_code(self, code_with_tags: str) -> ExecutionResult:
        """
        Execute Python code safely.
        
        Args:
            code_with_tags: Code wrapped in <execute_python> tags
            
        Returns:
            ExecutionResult containing execution details
            
        Raises:
            ValueError: If code extraction fails
            RuntimeError: If execution fails
        """
        start_time = asyncio.get_event_loop().time()
        
        try:
            # Extract code from tags
            code = self.extract_code(code_with_tags)
            
            # Validate imports
            self._validate_imports(code)
            
            # Create temporary file for execution
            with tempfile.NamedTemporaryFile(mode='w', suffix='.py', delete=False) as f:
                f.write(code)
                temp_file = f.name
            
            try:
                # Execute code in subprocess with timeout
                result = await asyncio.wait_for(
                    self._run_subprocess(temp_file),
                    timeout=self.timeout
                )
                
                execution_time = asyncio.get_event_loop().time() - start_time
                
                # Check for generated files
                generated_files = self._find_generated_files()
                
                return ExecutionResult(
                    success=result.returncode == 0,
                    output=result.stdout,
                    error=result.stderr if result.returncode != 0 else None,
                    execution_time=execution_time,
                    generated_files=generated_files,
                    return_code=result.returncode
                )
                
            finally:
                # Clean up temporary file
                os.unlink(temp_file)
                
        except asyncio.TimeoutError:
            execution_time = asyncio.get_event_loop().time() - start_time
            return ExecutionResult(
                success=False,
                output="",
                error=f"Execution timed out after {self.timeout} seconds",
                execution_time=execution_time,
                generated_files=[],
                return_code=-1
            )
        except Exception as e:
            execution_time = asyncio.get_event_loop().time() - start_time
            return ExecutionResult(
                success=False,
                output="",
                error=str(e),
                execution_time=execution_time,
                generated_files=[],
                return_code=-1
            )
    
    def _validate_imports(self, code: str) -> None:
        """
        Validate that only allowed imports are used.
        
        Args:
            code: Python code to validate
            
        Raises:
            ValueError: If disallowed imports are found
        """
        import_pattern = r'^(?:from\s+(\w+)|import\s+(\w+))'
        
        for line in code.split('\n'):
            line = line.strip()
            if line.startswith(('import ', 'from ')):
                match = re.match(import_pattern, line)
                if match:
                    module = match.group(1) or match.group(2)
                    if module not in self.allowed_imports:
                        raise ValueError(f"Import '{module}' not allowed. Allowed: {self.allowed_imports}")
    
    async def _run_subprocess(self, script_path: str) -> subprocess.CompletedProcess:
        """
        Run Python script in subprocess.
        
        Args:
            script_path: Path to Python script
            
        Returns:
            CompletedProcess result
        """
        # Set up environment with output directory
        env = os.environ.copy()
        env['MPLBACKEND'] = 'Agg'  # Use non-interactive backend
        env['PYTHONPATH'] = str(self.output_dir)
        
        # Run the script
        process = await asyncio.create_subprocess_exec(
            'python', script_path,
            stdout=asyncio.subprocess.PIPE,
            stderr=asyncio.subprocess.PIPE,
            cwd=str(self.output_dir),
            env=env
        )
        
        stdout, stderr = await process.communicate()
        
        return subprocess.CompletedProcess(
            args=['python', script_path],
            returncode=process.returncode,
            stdout=stdout.decode('utf-8'),
            stderr=stderr.decode('utf-8')
        )
    
    def _find_generated_files(self) -> List[str]:
        """
        Find files generated during execution.
        
        Returns:
            List of generated file paths
        """
        generated_files = []
        
        # Look for common chart file extensions
        chart_extensions = ['.png', '.jpg', '.jpeg', '.svg', '.pdf']
        
        for file_path in self.output_dir.iterdir():
            if file_path.is_file() and file_path.suffix.lower() in chart_extensions:
                generated_files.append(str(file_path))
        
        return generated_files
